<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>G検定 学習アプリ</title>
<style>
:root {
  --green: #10b981;
  --teal: #06b6d4;
  --orange: #f59e0b;
  --red: #ef4444;
  --bg: #0f172a;
  --card: #1e293b;
  --card-hover: #334155;
  --text: #f1f5f9;
  --text-sub: #94a3b8;
  --accent: #6366f1;
  --accent-hover: #818cf8;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Hiragino Sans', sans-serif;
  background: var(--bg); color: var(--text); min-height: 100vh; overflow-x: hidden;
}
.header {
  background: linear-gradient(135deg, #1e1b4b, #312e81);
  padding: 20px; text-align: center; position: sticky; top: 0; z-index: 100;
  box-shadow: 0 4px 20px rgba(0,0,0,0.3);
}
.header h1 { font-size: 1.3rem; font-weight: 700; letter-spacing: 0.05em; }
.header-sub { font-size: 0.75rem; color: var(--text-sub); margin-top: 4px; }
.screen { display: none; padding: 16px; padding-bottom: 100px; }
.screen.active { display: block; }
.overall-stats {
  background: linear-gradient(135deg, var(--card), #253348);
  border-radius: 16px; padding: 20px; margin-bottom: 20px; text-align: center;
}
.overall-rate {
  font-size: 2.8rem; font-weight: 800;
  background: linear-gradient(135deg, var(--accent), var(--teal));
  -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
}
.overall-label { font-size: 0.85rem; color: var(--text-sub); margin-top: 4px; }
.overall-detail {
  display: flex; justify-content: center; gap: 24px;
  margin-top: 12px; font-size: 0.85rem; color: var(--text-sub);
}
.section-title {
  font-size: 1rem; font-weight: 700; margin: 24px 0 12px;
  display: flex; align-items: center; gap: 8px;
}
.chapter-card {
  background: var(--card); border-radius: 12px; padding: 16px;
  margin-bottom: 12px; border-left: 4px solid transparent; transition: transform 0.15s;
}
.chapter-card:active { transform: scale(0.98); }
.chapter-card.excellent { border-left-color: var(--green); }
.chapter-card.good { border-left-color: var(--teal); }
.chapter-card.needs-work { border-left-color: var(--orange); }
.chapter-card.weak { border-left-color: var(--red); }
.chapter-header {
  display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;
}
.chapter-name { font-size: 0.9rem; font-weight: 600; flex: 1; margin-right: 12px; }
.chapter-rate { font-size: 1.3rem; font-weight: 800; }
.chapter-card.excellent .chapter-rate { color: var(--green); }
.chapter-card.good .chapter-rate { color: var(--teal); }
.chapter-card.needs-work .chapter-rate { color: var(--orange); }
.chapter-card.weak .chapter-rate { color: var(--red); }
.chapter-detail { font-size: 0.75rem; color: var(--text-sub); margin-bottom: 8px; }
.progress-bar {
  width: 100%; height: 6px; background: rgba(255,255,255,0.1);
  border-radius: 3px; overflow: hidden;
}
.progress-fill { height: 100%; border-radius: 3px; transition: width 0.5s ease; }
.chapter-card.excellent .progress-fill { background: var(--green); }
.chapter-card.good .progress-fill { background: var(--teal); }
.chapter-card.needs-work .progress-fill { background: var(--orange); }
.chapter-card.weak .progress-fill { background: var(--red); }
.badge {
  display: inline-block; font-size: 0.65rem; font-weight: 700;
  padding: 2px 8px; border-radius: 10px; margin-left: 8px; vertical-align: middle;
}
.badge.excellent { background: rgba(16,185,129,0.2); color: var(--green); }
.badge.good { background: rgba(6,182,212,0.2); color: var(--teal); }
.badge.needs-work { background: rgba(245,158,11,0.2); color: var(--orange); }
.badge.weak { background: rgba(239,68,68,0.2); color: var(--red); }
.chapter-select-card {
  background: var(--card); border-radius: 12px; padding: 16px; margin-bottom: 10px;
  display: flex; justify-content: space-between; align-items: center;
  cursor: pointer; transition: background 0.15s;
}
.chapter-select-card:active { background: var(--card-hover); }
.chapter-select-info h3 { font-size: 0.9rem; font-weight: 600; }
.chapter-select-info p { font-size: 0.75rem; color: var(--text-sub); margin-top: 2px; }
.chapter-select-arrow { color: var(--text-sub); font-size: 1.2rem; }
.quiz-progress { display: flex; align-items: center; gap: 12px; margin-bottom: 20px; }
.quiz-progress-bar { flex: 1; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; }
.quiz-progress-fill { height: 100%; background: var(--accent); border-radius: 2px; transition: width 0.3s; }
.quiz-progress-text { font-size: 0.8rem; color: var(--text-sub); white-space: nowrap; }
.question-card {
  background: var(--card); border-radius: 16px; padding: 24px 20px; margin-bottom: 16px;
}
.question-number { font-size: 0.75rem; color: var(--accent); font-weight: 700; margin-bottom: 8px; }
.question-text { font-size: 1rem; line-height: 1.7; font-weight: 500; }
.question-type {
  display: inline-block; font-size: 0.7rem; font-weight: 700; padding: 2px 8px;
  border-radius: 8px; margin-top: 8px;
  background: rgba(245,158,11,0.2); color: var(--orange);
}
.choices { display: flex; flex-direction: column; gap: 10px; }
.choice-btn {
  background: var(--card); border: 2px solid rgba(255,255,255,0.1); border-radius: 12px;
  padding: 14px 16px; color: var(--text); font-size: 0.9rem; line-height: 1.5;
  text-align: left; cursor: pointer; transition: all 0.15s;
  display: flex; align-items: flex-start; gap: 10px;
}
.choice-btn:active { transform: scale(0.98); }
.choice-btn.selected { border-color: var(--accent); background: rgba(99,102,241,0.15); }
.choice-btn.selected .choice-label { background: var(--accent); color: #fff; }
.choice-label {
  display: inline-flex; align-items: center; justify-content: center;
  width: 28px; height: 28px; border-radius: 50%; background: rgba(255,255,255,0.1);
  font-size: 0.8rem; font-weight: 700; flex-shrink: 0;
}
.choice-text { padding-top: 3px; }
.choice-btn.correct { border-color: var(--green); background: rgba(16,185,129,0.15); }
.choice-btn.correct .choice-label { background: var(--green); color: #fff; }
.choice-btn.incorrect { border-color: var(--red); background: rgba(239,68,68,0.15); }
.choice-btn.incorrect .choice-label { background: var(--red); color: #fff; }
.choice-btn.show-correct { border-color: var(--green); background: rgba(16,185,129,0.1); }
.submit-btn {
  width: 100%; padding: 14px; border-radius: 12px; border: none;
  font-size: 1rem; font-weight: 700; cursor: pointer; margin-top: 16px;
  background: var(--accent); color: #fff; transition: all 0.15s; display: none;
}
.submit-btn.show { display: block; }
.submit-btn:disabled { opacity: 0.4; cursor: not-allowed; }
.result-box { margin-top: 16px; padding: 16px; border-radius: 12px; display: none; }
.result-box.show { display: block; }
.result-box.correct-result { background: rgba(16,185,129,0.1); border: 1px solid rgba(16,185,129,0.3); }
.result-box.incorrect-result { background: rgba(239,68,68,0.1); border: 1px solid rgba(239,68,68,0.3); }
.result-icon { font-size: 1.5rem; margin-bottom: 8px; }
.result-explanation { font-size: 0.85rem; line-height: 1.6; color: var(--text-sub); margin-top: 8px; }
.next-btn, .copy-btn {
  width: 100%; padding: 14px; border-radius: 12px; border: none;
  font-size: 1rem; font-weight: 700; cursor: pointer; margin-top: 12px; transition: all 0.15s;
}
.next-btn { background: var(--accent); color: #fff; }
.copy-btn {
  background: rgba(255,255,255,0.1); color: var(--text);
  border: 1px solid rgba(255,255,255,0.2); font-size: 0.85rem;
}
.copy-btn.copied { background: rgba(16,185,129,0.2); border-color: var(--green); color: var(--green); }
.summary-hero { text-align: center; padding: 40px 20px; }
.summary-score { font-size: 4rem; font-weight: 800; }
.summary-score.great { color: var(--green); }
.summary-score.good { color: var(--teal); }
.summary-score.needs-work { color: var(--orange); }
.summary-score.poor { color: var(--red); }
.summary-label { font-size: 1rem; color: var(--text-sub); margin-top: 4px; }
.summary-detail { display: flex; justify-content: center; gap: 32px; margin-top: 20px; }
.summary-detail-item { text-align: center; }
.summary-detail-num { font-size: 1.5rem; font-weight: 700; }
.summary-detail-label { font-size: 0.75rem; color: var(--text-sub); }
.summary-q-item {
  background: var(--card); border-radius: 12px; padding: 14px 16px;
  margin-bottom: 8px; display: flex; align-items: flex-start; gap: 12px;
}
.summary-q-icon { font-size: 1.2rem; flex-shrink: 0; padding-top: 2px; }
.summary-q-text { font-size: 0.85rem; line-height: 1.5; flex: 1; }
.summary-q-copy {
  background: none; border: 1px solid rgba(255,255,255,0.2); color: var(--text-sub);
  font-size: 0.7rem; padding: 4px 10px; border-radius: 6px; cursor: pointer;
  white-space: nowrap; flex-shrink: 0;
}
.action-btns { display: flex; flex-direction: column; gap: 10px; margin-top: 24px; }
.btn-primary {
  background: var(--accent); color: #fff; border: none; padding: 16px;
  border-radius: 12px; font-size: 1rem; font-weight: 700; cursor: pointer;
}
.btn-secondary {
  background: rgba(255,255,255,0.08); color: var(--text);
  border: 1px solid rgba(255,255,255,0.15); padding: 14px; border-radius: 12px;
  font-size: 0.9rem; font-weight: 600; cursor: pointer;
}
.mode-cards { display: flex; flex-direction: column; gap: 12px; margin-top: 16px; }
.mode-card {
  background: var(--card); border-radius: 12px; padding: 20px; cursor: pointer;
  border: 2px solid transparent; transition: all 0.15s;
}
.mode-card:active { transform: scale(0.98); }
.mode-card h3 { font-size: 1rem; font-weight: 700; margin-bottom: 4px; }
.mode-card p { font-size: 0.8rem; color: var(--text-sub); line-height: 1.4; }
.no-data { text-align: center; padding: 40px 20px; color: var(--text-sub); }
.no-data-icon { font-size: 3rem; margin-bottom: 12px; }
.no-data p { font-size: 0.9rem; line-height: 1.6; }
.toast {
  position: fixed; bottom: 30px; left: 50%;
  transform: translateX(-50%) translateY(100px);
  background: var(--card); color: var(--text); padding: 12px 24px;
  border-radius: 12px; font-size: 0.85rem; font-weight: 600;
  box-shadow: 0 8px 30px rgba(0,0,0,0.4); z-index: 200;
  transition: transform 0.3s ease; pointer-events: none;
}
.toast.show { transform: translateX(-50%) translateY(0); }
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}
.fade-in { animation: fadeIn 0.3s ease forwards; }
.reset-area { margin-top: 40px; text-align: center; }
.reset-btn {
  background: none; border: 1px solid rgba(239,68,68,0.3); color: var(--red);
  padding: 10px 20px; border-radius: 8px; font-size: 0.8rem; cursor: pointer;
}
.overlay {
  display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6);
  z-index: 300; align-items: center; justify-content: center;
}
.overlay.show { display: flex; }
.dialog {
  background: var(--card); border-radius: 16px; padding: 24px; margin: 20px;
  max-width: 320px; width: 100%; text-align: center;
}
.dialog h3 { font-size: 1.1rem; margin-bottom: 8px; }
.dialog p { font-size: 0.85rem; color: var(--text-sub); margin-bottom: 20px; line-height: 1.5; }
.dialog-btns { display: flex; gap: 10px; }
.dialog-btns button {
  flex: 1; padding: 12px; border-radius: 10px; font-size: 0.9rem;
  font-weight: 600; cursor: pointer; border: none;
}
.dialog-cancel { background: rgba(255,255,255,0.1); color: var(--text); }
.dialog-confirm { background: var(--red); color: #fff; }
</style>
</head>
<body>
<div class="header">
  <h1>G検定 学習アプリ</h1>
  <div class="header-sub">JDLA Deep Learning for GENERAL</div>
</div>
<div class="toast" id="toast"></div>
<div class="overlay" id="resetOverlay">
  <div class="dialog">
    <h3>データをリセット</h3>
    <p>すべての学習記録が削除されます。<br>この操作は取り消せません。</p>
    <div class="dialog-btns">
      <button class="dialog-cancel" onclick="closeResetDialog()">キャンセル</button>
      <button class="dialog-confirm" onclick="confirmReset()">リセット</button>
    </div>
  </div>
</div>
<div class="screen active" id="topScreen">
  <div id="overallStats"></div>
  <div id="chapterAnalysis"></div>
  <div class="section-title">学習を始める</div>
  <div class="mode-cards">
    <div class="mode-card" onclick="showChapterSelect('normal')">
      <h3>章を選んで学習</h3>
      <p>章ごとに問題を解いて理解度を確認</p>
    </div>
    <div class="mode-card" onclick="startReviewMode()">
      <h3>間違えた問題を復習</h3>
      <p>過去に不正解だった問題を重点的に復習</p>
    </div>
    <div class="mode-card" onclick="showChapterSelect('all')">
      <h3>全章ランダム</h3>
      <p>全範囲からランダムに出題</p>
    </div>
  </div>
  <div class="reset-area">
    <button class="reset-btn" onclick="showResetDialog()">学習データをリセット</button>
  </div>
</div>
<div class="screen" id="chapterSelectScreen">
  <div class="section-title">
    <span onclick="goTop()" style="cursor:pointer;">← </span>
    章を選択
  </div>
  <div id="chapterList"></div>
</div>
<div class="screen" id="quizScreen">
  <div class="quiz-progress">
    <span onclick="confirmQuit()" style="cursor:pointer;font-size:1.2rem;">← </span>
    <div class="quiz-progress-bar">
      <div class="quiz-progress-fill" id="quizProgressFill"></div>
    </div>
    <div class="quiz-progress-text" id="quizProgressText">1/10</div>
  </div>
  <div id="quizContent"></div>
</div>
<div class="screen" id="summaryScreen">
  <div id="summaryContent"></div>
</div>

<script>
// ===== 問題データ（ここを差し替えるだけでOK） =====
var QUESTIONS = [
{"id":1,"chapter":1,"chapterName":"人工知能（AI）とは","question":"人工知能の定義は専門家の間ですら異なる。その説明として適切なものを1つ選べ。","choices":["人工知能は学術的な研究分野の1つとして認められていないから。","「人工」の解釈が研究者によって異なるから。","「知性」や「知能」の解釈が研究者によって異なるから。","人工知能という言葉は、人工知能研究者ジョン・マッカーシーが彼の論文で私的に使った造語だから。"],"correct":[2],"explanation":"人工知能は学術的な研究分野の1つとして認められており、国際学会も頻繁に行われています。「人工」とは「人の手を加えた、自然のままではない」という意味で研究者の間で意見は一致していると考えられます。人工知能という言葉をジョン・マッカーシーが最初に用いたのは、ダートマス会議です。"},
{"id":2,"chapter":1,"chapterName":"人工知能（AI）とは","question":"人工知能の定義に関する説明として、不適切なものを1つ選べ。","choices":["人工知能とは何かについては、専門家の間でも共有されている定義は未だにない。","「周囲の状況(入力)によって行動(出力)を変えるエージェント」として人工知能をとらえた場合、あらかじめ単純な振る舞いが決まっている製品も人工知能を搭載した製品だといえる。","同じシステムを指して、それを人工知能だと主張する人と、それは人工知能ではないと考える人がいてもおかしくない。","知的な処理能力を持つ機械(情報処理システム)であれば、誰もがそれを人工知能であると認めることができる。"],"correct":[3],"explanation":"人工知能の定義は専門家の間でも共有されていないため、同じシステムを指して、それを人工知能だと主張する人と、それは人工知能ではないと考える人がいてもおかしくありません。「人間と同じ知的な処理能力を持つ機械」という表現の「人間と同じ知的な処理能力」という部分の解釈が人によって異なる可能性があります。"},
{"id":3,"chapter":1,"chapterName":"人工知能（AI）とは","question":"機械学習を取り入れた人工知能に関する説明として、最も適しているものを1つ選べ。","choices":["サンプルデータが少なくても高い精度で入力と出力の関係を学習する。","制御工学やシステム工学と呼ばれる分野で培われた技術を利用している。","全ての振る舞いがあらかじめ決められている。","パターン認識という古くからの研究をベースにしている。"],"correct":[3],"explanation":"機械学習は、非常に多くのデータサンプルを使って学習することで高い精度の学習を達成することができます。機械学習は、データが持つ特徴(構造やパターン)を学習するので、パターン認識という古くからの研究をベースにしています。"},
{"id":4,"chapter":1,"chapterName":"人工知能（AI）とは","question":"AI効果の例として、最も適切なものを1つ選べ。","choices":["AIを活用したチャットボットと会話していたら、人間と会話しているように感じた。","検索エンジンにはAIが使われているが、その原理が人々に認知されるとAIとは呼ばれなくなった。","青りんごの実物を見たことがなかったが、初めて青いりんごを見たときに青りんごだと認識できた。","AIブームが起こると、家電などの身近なハードウェアがAI搭載を謳うようになった。"],"correct":[1],"explanation":"1はチューリングテスト、3はシンボルグラウンディング問題、4はAIブームに便乗するマーケティング戦略に関する事例です。"},
{"id":5,"chapter":1,"chapterName":"人工知能（AI）とは","question":"人工知能とロボットの研究に関する説明として、不適切なものを1つ選べ。","choices":["脳以外の部分を研究対象としているロボットの研究者は人工知能の研究者ではない。","人工知能の研究では「考える(知的な処理能力)」という「目に見えないもの」を中心に扱っている。","物理的な身体を必要としない将棋や囲碁のようなゲームもロボット研究の重要な研究対象である。","人工知能の研究はロボットの脳だけを対象にしているわけではない。"],"correct":[2],"explanation":"物理的な身体を必要としない将棋や囲碁のようなゲームを重要な研究対象としているのは、ロボット研究ではなく人工知能の研究です。"},
{"id":6,"chapter":1,"chapterName":"人工知能（AI）とは","question":"人工知能が持つ知的な処理能力として、最も不適切なものを1つ選べ。","choices":["モノを高速に移動させる運動能力","自動車の位置を特定する推論能力","障害物を回避する経路判定能力","複数の人の音声を聴き分ける認識能力"],"correct":[0],"explanation":"「モノを高速に移動させる運動能力」は物理的なモノを動かす能力であり、「考える」という人工知能が持つ知的な処理能力ではありません。"},
{"id":7,"chapter":1,"chapterName":"人工知能（AI）とは","question":"以下の文章を読み、空欄に最もよく当てはまるものを1つ選べ。\n1980年代に起こった第2次AIブームにおいては、( )によって問題を解決する古典的な人工知能が台頭した。","choices":["探索と推論","機械学習","エキスパートシステム","ビッグデータ"],"correct":[2],"explanation":"「探索と推論」は第1次AIブーム、「機械学習」と「ビッグデータ」は第3次AIブームで中心的な役割を果たします。第2次AIブームの主役は、専門家の「知識」をデータベースに蓄積した「エキスパートシステム」です。"},
{"id":8,"chapter":1,"chapterName":"人工知能（AI）とは","question":"1956年に開催されたダートマス会議についての説明として、最も不適切なものを1つ選べ。","choices":["この会議で「人工知能」という言葉が初めて使われた。","コンピュータを用いて数学の定理を自動的に証明することが、実現可能であることが示された。","後に人工知能や情報理論の研究で重要な役割を果たす著名な研究者たちが参加していた。","圧倒的な計算力を持つエニアック(ENIAC)が紹介され、コンピュータが人間の能力を凌駕する可能性について議論された。"],"correct":[3],"explanation":"世界初の汎用電子式コンピュータであるエニアック(ENIAC)は、ダートマス会議の10年前に誕生し、いずれコンピュータが人間の能力を凌駕するだろうという可能性を見出すきっかけとなりました。"},
{"id":9,"chapter":1,"chapterName":"人工知能（AI）とは","question":"「人工知能研究50年来のブレイクスルー」と称されるディープラーニングだが、その手法自体は第3次AIブームが盛り上がる以前から提案されていた。ここ数年になって急速な盛り上がりを見せているのにはいくつかの理由がある。その内容として最も不適切なものを1つ選べ。","choices":["大規模な並列計算処理が可能になったことで、現実的な時間内でモデルを学習させられるようになったから。","より大規模なデータがWeb上に公開されるようになり、データの収集が比較的容易になってきたから。","プログラミングを支援するフレームワークが広く普及したから。","政府によって「第五世代コンピュータ」と名付けられた大型プロジェクトが推進されたから。"],"correct":[3],"explanation":"第2次AIブームの時期、日本政府は第五世代コンピュータプロジェクトに巨額の資金を投じました。1982年から1992年の11年間にわたり、約500億円の国家予算を投じて遂行されました。"},
{"id":10,"chapter":1,"chapterName":"人工知能（AI）とは","question":"トイ・プロブレムに関する説明として、最も不適切なものを1つ選べ。","choices":["チェスや将棋などのトイ・プロブレムとは異なり、「ハノイの塔」は非常に複雑な問題であった。","トイ・プロブレムは、複雑な問題をコンピュータで扱えるように、本質を損なわない程度に問題を簡略化したものである。","我々が実際に直面し、本当に解決したい問題は、トイ・プロブレムよりもずっと複雑だった。","現実の問題が解けないという限界が明らかになり、人工知能研究はいったん下火となった。"],"correct":[0],"explanation":"「ハノイの塔」もチェスや将棋などと同様に明確なルールが定められたゲーム(非常に限定された状況で設定された問題)であり、トイ・プロブレムに分類されます。"},
{"id":11,"chapter":1,"chapterName":"人工知能（AI）とは","question":"人工知能研究の歴史と注目されてきた技術に関する説明として、最も適切なものを1つ選べ。","choices":["初期の人工知能はコンピュータの驚異的な計算力を利用して、複雑な問題を解くことしかできなかった。","第3次AIブームで注目されている知識ベースの人工知能では、人工知能が自ら学んだ知識を使用して推論を行うため、人間の知識を利用する必要はない。","第2次AIブームで盛んに研究された機械学習では、人工知能が自ら認識に必要な特徴量を発見してしまうため、応用が難しかった。","第1次AIブームで盛んに研究された探索ベースの手法は、人間が問題を適切に定義できればAIが問題を解くことができた。"],"correct":[3],"explanation":"初期の人工知能は「トイ・プロブレム」を解くことはできましたが、複雑な問題を解くことはできませんでした。知識ベースの人工知能が注目されたのは第2次AIブーム、ディープラーニングの研究が活性化するのは第3次AIブームです。"},
{"id":12,"chapter":1,"chapterName":"人工知能（AI）とは","question":"第2次AIブームでは、いかにして機械に知識を与えるかが大きなテーマになった。例えば自然言語処理の研究では、言葉同士の意味関係を定義する手法が提案された。しかし仮に言葉同士の意味関係が分かったとしても、現実の概念と結び付けられるかどうかという問題が待ち受けている。この問題の語句として、最も適切なものを1つ選べ。","choices":["シンボルグラウンディング問題","フレーム問題","最適化問題","組み合わせ爆発問題"],"correct":[0],"explanation":"言葉で表現した概念同士の意味関係が分かったとしても、言葉はあくまでも「記号」であり、実物そのものではありません。記号だけでは実際にそれが何を意味しているのかは本当の意味で理解できないというシンボルグラウンディング問題は解決できません。"},
{"id":13,"chapter":1,"chapterName":"人工知能（AI）とは","question":"異なる部屋にいる人間とコンピュータとが対話をし、話し相手がコンピュータであることを人間が見抜けなければ、コンピュータには知能があるとする判定方法を使ったテストに合格しても、「本当に知能があるかは分からない」という議論として最も適切なものを1つ選べ。","choices":["中国語の部屋","チューリングテスト","イライザ","ローブナーコンテスト"],"correct":[0],"explanation":"ジョン・サールは「中国語の部屋」という思考実験を通して、チューリングテストに合格しても、コンピュータは記号操作をしているだけで本当に知能があるかは分からないということを主張しました。"},
{"id":14,"chapter":1,"chapterName":"人工知能（AI）とは","question":"ルールベース機械翻訳の説明として、最も不適切なものを1つ選べ。","choices":["人間が用意した文法法則と辞書情報を使って翻訳する。","統計的機械翻訳やニューラル機械翻訳と比べて計算量が少ない。","訳文が形式的な表現になり、口語への対応が難しい。","大量のコーパスを学習させて翻訳モデルを構築するため、人手がかからず、高度な言語知識も不要である。"],"correct":[3],"explanation":"ルールベース機械翻訳は、人間が用意したルール(文法法則や辞書情報)を使って形式的に翻訳を行います。大量の言語データを必要とする統計的機械翻訳やニューラル機械翻訳と比べて計算量は少なくて済みますが、多様な口語表現に柔軟に対応するのが難しいというデメリットもあります。"},
{"id":15,"chapter":1,"chapterName":"人工知能（AI）とは","question":"以下の文章を読み、空欄(A)(B)に最もよく当てはまるものを1つ選べ。\n1990年代以降、(A)と呼ばれる機械翻訳が一般的に用いられるようになった。(A)は以前の翻訳手法と比較して性能は飛躍的に向上したが、文法的には正しいものの人間には不自然に感じられる訳を出力することがあり、実用レベルとはいえなかった。この理由の1つとして、人間が持っている一般常識を人工知能に習得させることは困難である(B)が挙げられる。","choices":["(A)統計的機械翻訳 (B)知識獲得のボトルネック","(A)統計的機械翻訳 (B)フレーム問題","(A)ニューラル機械翻訳 (B)知識獲得のボトルネック","(A)ニューラル機械翻訳 (B)フレーム問題"],"correct":[0],"explanation":"フレーム問題は「今行おうとしていることに関係のある事柄だけを選び出すことが実は難しい」という難題です。ニューラル機械翻訳の登場により機械翻訳の品質が格段に向上しました。"},
{"id":16,"chapter":1,"chapterName":"人工知能（AI）とは","question":"フレーム問題に関する説明として、不適切なものを1つ選べ。","choices":["フレーム問題は1969年にジョン・マッカーシーとパトリック・ヘイズが提唱した問題で、「今しようとしていることに関係のあることがらだけを選び出すことが実は非常に難しい」という問題である。","フレーム問題はディープラーニングが登場した現在もまだ解決していない。","哲学者のダニエル・デネットは、洞窟から爆弾を運び出すことを命じられたロボットが考えすぎてフリーズしてしまうたとえ話を通して、フレーム問題の難しさを説明している。","フレーム問題は人工知能に特有の問題であり人間には起きないと考えられる。"],"correct":[3],"explanation":"フレーム問題は未だに本質的な解決はされていません。人間も考えすぎて行動できなかったりするので、フレーム問題は人間にも起きると考えられます。しかし人間はあらゆる状況について無限に考えてフリーズすることはありません。"},
{"id":17,"chapter":1,"chapterName":"人工知能（AI）とは","question":"チューリングテストに関する説明として、不適切なものを1つ選べ。","choices":["チューリングテストは、人工知能の会話能力レベルを判定する方法の1つとして、イギリスの数学者アラン・チューリングが提唱したものである。","1966年にジョセフ・ワイゼンバウムによって開発されたイライザ(ELIZA)は、精神科のセラピストの役割を演じるプログラムで、本物のセラピストと信じてしまう人も現れた。しかしイライザはチューリングテストにパスしていない。","1991年以降、チューリングテストに合格する会話ソフトウェアを目指すローブナーコンテストが毎年開催されている。","1950年の論文の中でアラン・チューリングは50年以内に質問者が5分間質問した後の判定でコンピュータを人間と誤認する確率は30%であると見積もった。現在もまだチューリングテストにパスする会話ソフトウェアは現れていない。"],"correct":[0],"explanation":"チューリングテストは「人工知能の会話能力レベル」を判定するためではなく、「人工知能ができたかどうか」を判定するためのテストとして提案されました。"},
{"id":18,"chapter":1,"chapterName":"人工知能（AI）とは","question":"強いAIと弱いAIに関する説明として、不適切なものを1つ選べ。","choices":["「強いAI」「弱いAI」という言葉は、アメリカの哲学者ジョン・サールが提示したAIの区分である。「強いAI」は「本物の心を持つ人工知能はコンピュータで実現できる」と考える立場で、「弱いAI」は「コンピュータは人間の心を模倣するだけで、本物の心を持つことはできない」と考える立場である。","ジョン・サールは「強いAI」は実現可能だと主張し、「中国語の部屋」という思考実験を提案した。","「中国語の部屋」はチューリングテストを拡張した、心がどこに存在するのか、あるいは意味はどこにあるのか、という問題に対する思考実験だといえる。","ブラックホールの研究で有名なスティーブン・ホーキングと共同研究をしたことで有名な数学者のロジャー・ペンローズは、意識は脳の中にある微細な管に生じる量子効果が絡んでいるので、既存のコンピュータでは「強いAI」は実現できないと主張している。"],"correct":[1],"explanation":"ジョン・サール自身は「強いAI」は実現不可能だと主張し、自らの立場を説明するために「中国語の部屋」という思考実験を提案しました。"},
{"id":19,"chapter":1,"chapterName":"人工知能（AI）とは","question":"シンボルグラウンディング問題に関する説明として、不適切なものを1つ選べ。","choices":["シンボルグラウンディング問題とは、記号(シンボル)とその対象がいかにして結び付くのかという問題で、認知科学者のスティーブン・ハルナッドにより議論された。","人間の場合もシンボルグラウンディング問題は起きる。","身体がないとシンボルグラウンディング問題は解決できないと考えるのが身体性というアプローチである。","シンボルグラウンディング問題は、フレーム問題と同様にまだ解決されておらず、人工知能の難問とされている。"],"correct":[1],"explanation":"コンピュータは記号の意味が分かっていないので、記号が意味する対象と記号を自動的に結びつけることができません。人間の場合はシンボルグラウンディング問題が起きません。人間が身体を通して概念を獲得しているからです。"},
{"id":20,"chapter":1,"chapterName":"人工知能（AI）とは","question":"知識獲得のボトルネックに関する説明として、不適切なものを1つ選べ。","choices":["機械翻訳は人工知能の研究の古くからのテーマであり、1970年代後半はルールベースの機械翻訳が主流であったが、1990年代後半から統計的機械翻訳が主流になった。翻訳精度は飛躍的に向上したが、まだまだ実用レベルではなかった。","統計的機械翻訳は、膨大な対訳データ(コーパス)を利用して文単位のレベルで翻訳できたので、一般常識がなくても精度の高い翻訳ができた。","人間の持っている一般常識は膨大で、それらすべての知識をコンピュータが扱うことは極めて困難である。コンピュータが知識を獲得することの難しさを、人工知能の分野では知識獲得のボトルネックと呼んでいる。","ディープラーニングを使ったニューラル機械翻訳という技術が登場したことで、機械翻訳の品質が統計的機械翻訳の品質を上回った。"],"correct":[1],"explanation":"統計的機械翻訳は膨大な文字データを利用して文単位のレベルで翻訳できましたが、一般常識が必要とされるレベルの翻訳はできませんでした。"},
{"id":21,"chapter":1,"chapterName":"人工知能（AI）とは","question":"特徴量に関する説明として、不適切なものを1つ選べ。","choices":["機械学習では、注目すべきデータの特徴の選び方が性能を決定づけてしまう。注目すべきデータの特徴を量的に表したものを特徴量と呼ぶ。","よい特徴量を人間が見つけ出すのは非常に難しいため、機械学習自身に特徴量を発見させるアプローチを特徴表現学習と呼ぶ。ディープラーニングは特徴表現学習を行う機械学習アルゴリズムの1つである。","ディープラーニングは階層ごとに単純な概念から複雑な概念を構築することができる特徴量を抽出していると考えられる。","機械学習は人間には理解できない特徴量を自動的に抽出してしまうので「判断理由を説明できないブラックボックス型の人工知能」だといわれている。"],"correct":[3],"explanation":"「判断理由を説明できないブラックボックス型の人工知能」だといわれているのはディープラーニングであり、全ての機械学習がブラックボックス型というわけではありません。"},
{"id":22,"chapter":1,"chapterName":"人工知能（AI）とは","question":"ある店舗のある日の午後のビールの売り上げ予想のために用いる特徴量として適切ではないと考えられるものを1つ選べ。","choices":["当日の午前中の平均気温","当日の午後の天気予報","前日の午後の入店者数","前日の購買者の平均年齢"],"correct":[3],"explanation":"予想しているのはある店舗のある日の午後のビールの売り上げなので、前日の購買者の平均年齢を特徴量として利用しても意味がありません。"},
{"id":23,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"以下の文章を読み、空欄に当てはまる言葉の組み合わせとして、最も適切なものを1つ選べ。\n迷路をコンピュータに理解できる構造で表現する方法の1つに(ア)がある。これは枝分かれする木のような構造をしており、それぞれの枝が条件の異なる場合分けに対応している。枝を探索する方法には(イ)と(ウ)があり、(イ)であれば最短距離でゴールにたどり着く解を必ず見つけることができるが、メモリ不足となる可能性がある。一方、(ウ)では最短距離でゴールにたどり着く解とは限らない。","choices":["(ア)検索木 (イ)深さ優先探索 (ウ)幅優先探索","(ア)検索木 (イ)幅優先探索 (ウ)深さ優先探索","(ア)探索木 (イ)深さ優先探索 (ウ)幅優先探索","(ア)探索木 (イ)幅優先探索 (ウ)深さ優先探索"],"correct":[3],"explanation":"探索木は迷路を枝分かれする木のような構造で表現する方法です。幅優先探索は最短距離でゴールにたどり着く解を必ず見つけることができますが、メモリ不足になる可能性があります。深さ優先探索はメモリ不足にはなりませんが、最短距離とは限りません。"},
{"id":24,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"下図のような木構造で表された迷路において、スタート(S)からゴール(G)までたどり着くパスを探索する場合、最も適切なものを1つ選べ。","choices":["幅優先探索で3回","深さ優先探索で3回","幅優先探索で4回","深さ優先探索で4回"],"correct":[3],"explanation":"幅優先探索でGにたどり着くのは左側優先で6回、右側優先で5回です。深さ優先探索では右側優先で4回となります。"},
{"id":25,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"探索空間が大きすぎて事実上すべてを探索できないという問題に対処する方法に関する説明として、不適切なものを1つ選べ。","choices":["ヒューリスティックな知識を利用してコスト計算を行い、コストが高すぎる探索は行わないようにすることで探索効率を上げることができる。","ブルートフォース法は、コンピュータが2人の仮想的なプレイヤーを演じて、完全にランダムに手を指し続ける方法でゲームをシミュレーションする方法である。","Mini-Max法はαカット、βカットという枝刈りを行うことで探索効率を上げることができる。","コンピュータが完全にランダムな指し手でゲームを最後までプレイアウトすることを何度も繰り返し、一番勝率が高い手を見つけ出す。"],"correct":[1],"explanation":"選択肢2は「ブルートフォース法」ではなく「モンテカルロ法」の説明です。ブルートフォースとは探索可能な全パターンを力任せに処理することです。"},
{"id":26,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"オントロジーに関する説明として、不適切なものを1つ選べ。","choices":["オントロジーは、本来「存在論」という意味の哲学用語であるが、人工知能の用語としてはトム・グルーパーによる「概念化の明示的な仕様」という定義が広く受け入れられている。","オントロジーの研究は、エキスパートシステムのための知識ベースの開発と保守にはコストがかかるという問題意識に端を発している。","オントロジーの目的は知識の共有と活用である。","Cyc(サイク)プロジェクトは一般常識を全てデータベース化しようとしたプロジェクトで、ダグラス・レナートにより1984年からスタートし2014年まで30年間続いた。"],"correct":[3],"explanation":"Cycプロジェクトは現在も続いています。「Cyc」は「Encyclopedia(百科事典)」に由来しています。"},
{"id":27,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"意味ネットワークに関する説明として、適切なものを1つ選べ。\n意味ネットワークは「概念」と「概念間の関係」をネットワークとして表す。特に重要な関係として(ア)の関係と(イ)の関係がある。「哺乳類」と「動物」の関係は「(ア)の関係」、「足」と「犬」の関係は「(イ)の関係」である。","choices":["(ア)is-a (イ)named-from","(ア)named-from (イ)is-a","(ア)part-of (イ)named-from","(ア)named-from (イ)part-of","(ア)is-a (イ)part-of","(ア)part-of (イ)is-a"],"correct":[4],"explanation":"「哺乳類 is-a 動物」(哺乳類は動物「である」)、「足 part-of 犬」(足は犬の「一部である」)という関係が正解です。"},
{"id":28,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"「is-a」の関係と「part-of」の関係に関する説明として、不適切なものを1つ選べ。","choices":["オントロジーにおいて、「is-a」の関係は上位概念と下位概念の継承関係を表し、「part-of」の関係は属性を表す。","「is-a」の関係は推移律が必ず成立する。","「part-of」の関係でも推移律が必ず成立する。なぜなら、「日本 part-of アジア」と「東京 part-of 日本」と「東京 part-of アジア」が成立するからである。","「part-of」の関係には最低5つの関係があることが分かっており、コンピュータにこれを理解させるのは大変難しい。"],"correct":[2],"explanation":"「is-a」の関係は推移律が必ず成立しますが、「part-of」の関係では推移律が成立するとは限りません。例えば「指 part-of 太郎」と「太郎 part-of 野球部」が成立しても「指 part-of 野球部」は成立しません。"},
{"id":29,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"オントロジーの構築に関する説明として、不適切なものを1つ選べ。","choices":["オントロジーの研究が進むにつれ、ヘビーウェイトオントロジー、ライトウェイトオントロジーという2つの流れが生まれた。","ヘビーウェイトオントロジーは対象世界の知識をどのように記述するかを哲学的にしっかり考えて行う。ライトウェイトオントロジーはとにかくコンピュータにデータを読み込ませてできる限り自動的に行う。","Webデータを解析して知識を取り出すウェブマイニングやデータマイニングは、ヘビーウェイトオントロジーと相性が良い。","オントロジーの研究は、セマンティックWebやLOD(Linked Open Data)などの研究として展開されている。"],"correct":[2],"explanation":"ウェブマイニングやデータマイニングと相性が良いのは「ライトウェイトオントロジー」です。"},
{"id":30,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"機械学習とデータに関する説明として、不適切なものを1つ選べ。","choices":["機械学習はサンプルデータの数が多いほど望ましい学習結果が得られる。","2000年以降、インターネットの普及により急増したデータがビッグデータとして利用できるようになり、機械学習が実用化できるレベルに至った。","ディープラーニングが登場する前から利用されていたレコメンデーションエンジンやスパムフィルタは、高度な機械学習アルゴリズムを利用することで、ビッグデータを利用せずに実用化に成功したアプリケーションである。","インターネット上のWebページの爆発的な増加により、膨大な対訳データ(コーパス)を利用できるようになり、統計的自然言語処理を使って最も正解である確率が高い訳を選択できるようになった。"],"correct":[2],"explanation":"レコメンデーションエンジンやスパムフィルターは、ビッグデータを利用した機械学習を利用することで実用化に成功したアプリケーションです。"},
{"id":31,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"画像認識に関する説明として、不適切なものを1つ選べ。","choices":["2012年、画像認識の精度を争う競技会「ILSVRC」でジェフリー・ヒントンが率いるトロント大学のチームが開発したニューラルネットワークであるSuperVisionが圧勝した。","2012年以前のILSVRCで、画像認識に機械学習を用いることは既に常識になっていたが、機械学習で用いる特徴量を決めるのは人間だった。","2012年以降のILSVRCのチャンピオンは全てディープラーニングを利用している。","ディープラーニングは2015年に人間の画像認識エラーである4%を下回った。"],"correct":[0],"explanation":"SuperVisionはチームの名前です。SuperVisionが開発したニューラルネットワークは「AlexNet」と呼ばれています。"},
{"id":32,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"第1次AIブームにおける「探索」に関する説明として、最も不適切なものを1つ選べ。","choices":["幅優先探索はメモリがそれほど必要ないが、深さ優先探索は途中ノードを全て記憶するため多くのメモリが必要になる。","迷路に対して道の分岐パターンを網羅していくと、探索木を作成することができる。","探索木は要するに場合分けであり、こうした単純な作業はコンピュータが非常に得意とする処理である。","解に到達するまでの時間は、問題とその探索方法により異なる。"],"correct":[0],"explanation":"幅優先探索は答えにたどり着くまでに立ち寄ったノードを全て記憶しておかなければならないためメモリ不足になる可能性があります。深さ優先探索はメモリはあまり必要ありません。"},
{"id":33,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"ビッグデータについて述べたものとして、最も適切なものを1つ選べ。","choices":["ビッグデータとは、膨大な量のデータであり、データ量が1EB(10億GB)以上のものを指す。","ビッグデータとは、大容量のデータのうち構造化されたデータを指す。","ビッグデータを利用した機械学習が活性化したことが、第3次AIブームの一因である。","ビッグデータはそのデータ量が膨大であるため、データの更新頻度が低い。"],"correct":[2],"explanation":"ビッグデータの量に関する具体的な基準値は存在しません。非構造化データもビッグデータの対象です。データ量と更新頻度は無関係です。"},
{"id":34,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"Mini-Max法を改良し、効率よく同じ結果が得られるようにしたアルゴリズムの呼称として、最も適切なものを1つ選べ。","choices":["モンテカルロ法","ブルートフォース法","プレイアウト法","αβ法"],"correct":[3],"explanation":"モンテカルロ法は数多くランダムに手を打ち最良の手を選ぶ方法です。ブルートフォースは力任せに処理を行うことで、プレイアウトは最後までゲームを進めてしまう行為のことです。"},
{"id":35,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"以下の文章を読み、空欄に最もよく当てはまるものを1つ選べ。\n( )はロボットの行動計画などのプランニングのための手法であり、前提条件・行動・結果の3つで記述する。","choices":["STRIPS","SHRDLU","Cycプロジェクト","モンテカルロ法"],"correct":[0],"explanation":"STRIPSはロボット工学やAIにおける行動計画作成のための言語およびアルゴリズムのセットとして設計されました。SHRDLUは積み木の世界で対話で指示を受け取りプランニングできました。"},
{"id":36,"chapter":6,"chapterName":"生成AI","question":"以下の文章を読み、空欄に最もよく当てはまるものを1つ選べ。\n大規模言語モデルは与えられた大量の文章を学習することで、一般的な言語の構造、文法、語彙などの基本を学ぶが、それだけでは人間が望ましいと考える回答を生成できないため( )と呼ばれる学習も行う。","choices":["トランスフォーマー","アテンション","ファインチューニング","プリトレーニング"],"correct":[2],"explanation":"大規模言語モデルは事前学習(プリトレーニング)で一般的な言語の基本構造を学んだ後、ファインチューニングを行うことで適切な解答を生成する能力を向上させます。"},
{"id":37,"chapter":6,"chapterName":"生成AI","question":"トランスフォーマーとそれを用いた大規模言語モデル(LLM)に関する説明として、最も不適切なものを1つ選べ。","choices":["トランスフォーマーを利用することで、同じ単語でも文脈や状況で意味やニュアンスが変わることを効率よく学習できる。","大規模言語モデルの性能は、学習データ量に関係なくニューラルネットワークのパラメータの個数を増やせば増やしただけ向上する。","大規模言語モデルが特定の規模を超えると、事前に想定されていなかった能力を獲得することが報告されている。","トランスフォーマーは文章中の単語の位置を考慮し、単語と単語の関係性を広範囲に学習する。"],"correct":[1],"explanation":"ニューラルネットワークのパラメータの個数を増やしても、学習データや計算リソースが十分に足りていなければ性能向上は期待できません。"},
{"id":38,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"ある問題をコンピュータで解くため、探索木を考えた。幅優先探索で「スタートS」から「ゴールG」まで左側のノードを優先して探索を行った場合と右側のノードを優先して探索を行った場合では、(A)の方が探索回数は少なくて済む。また幅優先探索は深さ優先探索と比較して一般的に(B)という特徴がある。","choices":["(A)左側優先 (B)ゴールに最短距離でたどり着く解を必ず見つけられる","(A)左側優先 (B)メモリの使用量が少なくて済む","(A)右側優先 (B)ゴールに最短距離でたどり着く解を必ず見つけられる","(A)右側優先 (B)メモリの使用量が少なくて済む"],"correct":[2],"explanation":"右側優先の方が少ないステップでゴールに到達できます。幅優先探索はメモリの使用量が多くなりますが、最短距離で到達できる解を必ず見つけることができます。"},
{"id":39,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"迷路の問題を解く際に用いる探索木の探索において、深さ優先探索の説明として最も適切なものを1つ選べ。","choices":["探索木のルートから先に順にたどっていく。行き止まりにたどり着いたら1つ上のノードに戻って別の経路を探索する。最短距離でゴールにたどり着く経路とは限らない。","探索木のルートから近いノードを優先して探索する。最短距離でゴールにたどり着く経路を見つけることができる。","探索木のルートから近いノードを優先して探索する。近いノード1つだけ選ぶのでメモリが必要ない。","探索木のルートから先に順にたどっていく。全ての経路を記憶するのでメモリが必要となる。"],"correct":[0],"explanation":"深さ優先探索ではメモリの使用量が少なくて済みますが、最短距離でゴールにたどり着く経路とは限りません。"},
{"id":40,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"第3次AIブーム以降、ディープラーニングの活用が進んだ理由として、最も不適切なものを1つ選べ。","choices":["インターネットのサービスの普及と発展によって、Web上でデータが扱われるようになったため。","コンピュータのハードウェアの性能向上と共に、ビッグデータを扱えるような基盤が発展したため。","ディープラーニングの優れたアルゴリズムの開発が進んだため。","実ビジネスでルールベースAIの有益性が低下したため。"],"correct":[3],"explanation":"ルールベースのAIは特定の用途に特化した場合、非常に高い精度と効率を達成することが可能です。現在でも広く利用されています。"},
{"id":41,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"意味ネットワークを構築する上で重要となる概念間の関係性として、最も適切なものを1つ選べ。","choices":["「is-a」の関係","「have-to」の関係","「to-be」の関係","「can-be」の関係"],"correct":[0],"explanation":"「is-a」の関係は概念間の継承関係を表します。選択肢2、3、4のような関係は意味ネットワークでは定義されていません。"},
{"id":42,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"1964年から1966年にかけてジョセフ＝ワイゼンバウムによって開発されたイライザ(ELIZA)の説明として、最も不適切なものを1つ選べ。","choices":["過去の膨大な会話ログから、機械が自律的に学習することで自然な応答パターンをルール化できた。","あらかじめ用意されたパターンに合致すると、それに応じた発言を返答する仕組みになっている。","単純なルールに基づき機械的に生成された言葉でも、そこに知性があると感じて夢中になる人が現れた。","相手の発言を理解しているわけではなく機械的な処理で返答しているだけなので、人工無脳と呼ばれる。"],"correct":[0],"explanation":"イライザは相手の発言を理解しているわけではなく、基本的にオウム返しに相手の発言を再利用しているだけでした。学習機能はありません。"},
{"id":43,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"ウェブマイニングやデータマイニングにおいて知識を取り出す取り組みとして、最も適切なものを1つ選べ。","choices":["知識の関係性は必ず正しいとは限らないので、ライトウェイトオントロジーに属する。","知識の関係性は必ず決まっているので、ヘビーウェイトオントロジーに属する。","知識の関係性は必ず決まっているので、ライトウェイトオントロジーに属する。","知識はでたらめなこともあるので、モンテカルロ法に属する。"],"correct":[0],"explanation":"ライトウェイトオントロジーは完全に正しいものでなくても使えるものであればいいという考え方で、分類関係の正当性については深い考察は行わない傾向があります。"},
{"id":44,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"以下の文章を読み、空欄に最もよく当てはまるものを1つ選べ。\n( )は、血液中のバクテリアの診断支援をするプログラムで、「もし(if)以下の条件が成立すると、そうしたら(then)、その微生物は○○である」のルールに基づいて判定を行う。","choices":["イライザ(ELIZA)","エニアック(ENIAC)","マイシン(MYCIN)","アルファゼロ(AlphaZero)"],"correct":[2],"explanation":"マイシンは、あたかも感染症の専門医のように振る舞うことができました。"},
{"id":45,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"知識獲得のボトルネックの説明として、最も適切なものを1つ選べ。","choices":["人間から体系だった知識を引き出して、コンピュータに載せることが困難であること。","探索や推論を行う上で、組み合わせが指数関数や階乗のオーダーで爆発的に大きくなること。","大量の知識を処理する上で、コンピュータ計算速度が問題になったこと。","十分な知識を詰め込むためには、コンピュータの記憶容量は小さすぎたこと。"],"correct":[0],"explanation":"人間が持っている知識は膨大で、専門知識だけでなく一般常識も含めた全ての知識をコンピュータに獲得させることは難しいとされています。"},
{"id":46,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"ディープラーニングによる機械学習が注目されるきっかけとなった2012年の出来事として、最も適切なものを1つ選べ。","choices":["アメリカのクイズ番組Jeopardy!において、ディープラーニングによるアルゴリズムが人間の出演者に勝利した。","画像認識の精度に関する競技会のILSVRCにおいて、ディープラーニングが既存の手法を大きく上回る精度を達成した。","東京大学への入試問題において、ディープラーニングを用いた回答を行う「東ロボくん」が合格ラインを突破した。","囲碁の対戦において、ディープラーニングを用いた自己対戦により獲得されたモデルが人間の世界チャンピオンを破った。"],"correct":[1],"explanation":"2012年に開催されたILSVRCでディープラーニングを用いた手法が圧勝し、大きな注目を集めるきっかけとなりました。"},
{"id":47,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"次元の呪いに関する説明として、最も不適切なものを1つ選べ。","choices":["モデル作成時のデータの次元が高いと、機械学習の問題は解決が難しくなる場合が多い。","機械学習のモデルを作成する際に、想定できる最大の次元数まで増やさないと精度が出ないことが多い。","データの次元数が大きくなりすぎると、汎化性能が悪くなることが多い。","モデル作成時に利用するデータの次元数が増加すると、構成のパターンが指数関数的に増加することが多い。"],"correct":[1],"explanation":"精度に影響する特徴を適切な数だけ選択できれば、学習モデルは適切な精度を出すことができます。"},
{"id":48,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"次元の呪いについて、空欄(A)(B)に最もよく当てはまるものを1つ選べ。\n次元の呪いは、特徴量が多くなりすぎると(A)の向上が困難となる現象のことをいう。それを避けるためには特徴量の中から必要なものを選び出す(B)や、次元削減といった手法が取られている。","choices":["(A)汎化性能 (B)特徴選択","(A)汎化性能 (B)モデル圧縮","(A)学習率 (B)特徴選択","(A)学習率 (B)モデル圧縮"],"correct":[0],"explanation":"特徴量が多くなりすぎるとデータが不足している領域の予測が困難になります(汎化性能が向上しにくくなります)。"},
{"id":49,"chapter":2,"chapterName":"人工知能をめぐる動向","question":"特徴抽出の説明として、最も適切なものを1つ選べ。","choices":["あるデータからディープラーニングによって抽出された特徴量は、分類などのタスクに有用である。","ディープラーニングによる特徴抽出で得られた特徴は、サポートベクターマシン(SVM)などの他の機械学習モデルの入力としては使えない。","画像データは非常に複雑であるため、ディープラーニングによる特徴抽出は不可能である。","与えられたデータに対してニューラルネットワークなどのモデルで特徴抽出を行うと、必ずデータの次元は大きくなる。"],"correct":[0],"explanation":"ディープラーニングによって抽出した特徴は、データの分類問題を解くときにも有用です。"},
{"id":50,"chapter":3,"chapterName":"機械学習の具体的手法","question":"以下の文章を読み、空欄に最もよく当てはまるものを1つ選べ。\nブースティングは複数の弱分類器を組み合わせて1つの分類器を構築する( )の手法の1つである。","choices":["バギング","アンサンブル学習","ボルツマンマシン","サポートベクターマシン(SVM)"],"correct":[1],"explanation":"バギングもアンサンブル学習の手法の1つです。"},
{"id":51,"chapter":3,"chapterName":"機械学習の具体的手法","question":"サポートベクターマシン(SVM)において、データを(A)空間に写像することで線形分類を行えるようにする。その際に用いられる関数のことを(B)関数という。","choices":["(A)高次元 (B)カーネル","(A)高次元 (B)フーリエ","(A)低次元 (B)カーネル","(A)低次元 (B)フーリエ"],"correct":[0],"explanation":"カーネル関数を用いてデータを高次元空間に写像するのが非線形のSVMの特徴です。"},
{"id":52,"chapter":3,"chapterName":"機械学習の具体的手法","question":"バギングに関する説明として、最も適切なものを1つ選べ。","choices":["複数のモデルの中からランダムにモデルを選び、最も識別性能の高かったモデルを採用する手法のこと。","複数のモデルをそれぞれ別に学習させ、各モデルの出力を平均もしくは多数決することで決める手法のこと。","複数のモデルを学習させ、最も性能の低いモデルを不採用とすることを繰り返す手法のこと。","はじめに1つモデルを学習して作成し、それを何度も改善する手法のこと。"],"correct":[1],"explanation":"バギングはアンサンブル学習に位置付けられるので、複数のモデルの出力を利用するのが特長です。"},
{"id":53,"chapter":3,"chapterName":"機械学習の具体的手法","question":"複数の決定木を用意し、訓練データをランダムに振り分けて、アンサンブル学習を行う学習手法として、最も適切なものを1つ選べ。","choices":["B木","ドメインランダマイゼーション","ランダムフォレスト","勾配ブースティング決定木"],"correct":[2],"explanation":"ランダムフォレストもアンサンブル学習に位置付けられます。"},
{"id":54,"chapter":3,"chapterName":"機械学習の具体的手法","question":"回帰問題や分類問題に関する説明として、最も適切なものを1つ選べ。","choices":["多クラス分類には、ソフトマックス関数が用いられる。","回帰問題には、ロジスティック回帰が用いられる。","多クラス分類には、線形回帰が用いられる。","多クラス分類には、リッジ回帰が用いられる。"],"correct":[0],"explanation":"多クラス分類にはソフトマックス関数を用います。2値分類にロジスティック回帰、回帰問題に線形回帰またはリッジ回帰を用います。"},
{"id":55,"chapter":3,"chapterName":"機械学習の具体的手法","question":"自己回帰モデル(AR)による分析対象例として、最も適切なものを1つ選べ。","choices":["株価予測","迷惑メールの分類","検査画像を用いたがん細胞の検出","顔認証"],"correct":[0],"explanation":"ARは過去のデータを用いて現在のデータを回帰する時系列データの予測に用いることができます。"},
{"id":56,"chapter":3,"chapterName":"機械学習の具体的手法","question":"教師なし学習の手法の中で、クラスタごとに重心を求め、各データを最も近いクラスタに紐付ける作業を繰り返しあらかじめ決められた数のクラスタにデータを分類する手法として、最も適切なものを1つ選べ。","choices":["線形回帰","ブースティング","k-means法","主成分分析(PCA)"],"correct":[2],"explanation":"あらかじめ決めたk個のクラスタを作るために重心を求めて紐づけるのがk-means法の特長です。"},
{"id":57,"chapter":3,"chapterName":"機械学習の具体的手法","question":"サンプル同士の類似度をもとに、それらを複数のグループに分割する手法の名称として、最も適切なものを1つ選べ。","choices":["決定木","主成分分析(PCA)","クラスタリング","交差検証"],"correct":[2],"explanation":"クラスタリングがどのような処理であるか理解しましょう。"},
{"id":58,"chapter":3,"chapterName":"機械学習の具体的手法","question":"階層的クラスタリングにおいて、クラスタが形成されていく様子を木構造で表現した図の名称として、最も適切なものを1つ選べ。","choices":["デンドログラム","ヒストグラム","パレート図","決定木"],"correct":[0],"explanation":"木構造で表現した樹形図のようなクラスタを形成するのがデンドログラムの特徴です。"},
{"id":59,"chapter":3,"chapterName":"機械学習の具体的手法","question":"レコメンデーションに関する文章を読み、空欄(A)〜(C)に最もよく当てはまるものを1つ選べ。\n(A)はECサイト等でユーザーの購買履歴をもとに好みを分析しおすすめする手法である。(A)は事前にある程度の参考になるデータがない場合に推薦できない。これを(B)と言う。(C)は商品側に特徴量を付与し類似商品を推奨する。(C)は(B)を回避できる。","choices":["(A)コンテンツベースフィルタリング (B)コールドスタート問題 (C)協調フィルタリング","(A)協調フィルタリング (B)コールドスタート問題 (C)コンテンツベースフィルタリング","(A)コンテンツベースフィルタリング (B)ホットスタート問題 (C)協調フィルタリング","(A)協調フィルタリング (B)ホットスタート問題 (C)コンテンツベースフィルタリング"],"correct":[1],"explanation":"コールドスタート問題は重要な問題なので、どのように回避するかを含めて理解しましょう。"},
{"id":60,"chapter":3,"chapterName":"機械学習の具体的手法","question":"Q学習について述べたものとして、最も適切なものを1つ選べ。","choices":["行動価値関数を最適化するよう学習を進める手法である。","方策勾配法ベースの手法である。","行動器と評価器を用いる手法である。","方策オン型(オンポリシー)に分類される手法である。"],"correct":[0],"explanation":"Q学習は価値反復法ベースの手法であり、方策オフ型の学習手法です。"},
{"id":61,"chapter":3,"chapterName":"機械学習の具体的手法","question":"強化学習はマルコフ決定過程として定式化される。この場合のマルコフ性とは何か。最も適切なものを1つ選べ。","choices":["未来の状態は、現在の状態にのみ依存し、過去には依存しない。","未来の状態は、過去の状態と現在の状態とに依存する。","未来の状態は、過去の状態に依存し、現在の状態には依存しない。","未来の状態は、過去の状態にも、現在の状態にも依存しない。"],"correct":[0],"explanation":"マルコフ性は特に重要となるので理解しましょう。"},
{"id":62,"chapter":3,"chapterName":"機械学習の具体的手法","question":"機械学習における検証手法の1つであるk-分割交差検証は、どのようなときに用いると効果的か。最も適切なものを1つ選べ。","choices":["学習に時間がかかるとき。","分類問題におけるクラスの数が少ないとき。","入力データの次元が大きいとき。","データセットに含まれるデータの件数が少ないとき。"],"correct":[3],"explanation":"k-分割交差検証は、データセットに含まれるデータ件数が少ないときに効果的です。"},
{"id":63,"chapter":4,"chapterName":"ディープラーニングの概要","question":"ディープラーニングの説明として、最も不適切なものを1つ選べ。","choices":["ニューラルネットワークの隠れ層を深くしたものである。","他の多くのアルゴリズムと比べて一般的に計算量は少なくて済む。","非線形の回帰や分類を行うことができる。","過学習に陥る可能性がある。"],"correct":[1],"explanation":"ディープラーニングはさまざまな問題に適用できる一方、過学習することや計算量が必要なことなどを理解しましょう。"},
{"id":64,"chapter":4,"chapterName":"ディープラーニングの概要","question":"勾配消失問題の対策として、最も不適切なものを1つ選べ。","choices":["ReLU等の活性化関数を使用する。","バッチ正規化を行う。","スキップ結合をネットワークに組み込む。","ドロップアウトを行う。"],"correct":[3],"explanation":"ドロップアウトは過学習を抑制するのに効果的です。勾配消失問題の対策にはReLU等の活性化関数やスキップ結合が有効です。"},
{"id":65,"chapter":4,"chapterName":"ディープラーニングの概要","question":"以下の文章を読み、空欄に最もよく当てはまるものを1つ選べ。\n単純パーセプトロンでは非線形分類を行うことはできないが、( )と呼ばれる層を加えた多層パーセプトロンを用いることで非線形分類は可能となる。","choices":["隠れ層","プーリング層","活性化層","スキップ層"],"correct":[0],"explanation":"多層パーセプトロンは隠れ層を多層にした構造です。"},
{"id":66,"chapter":4,"chapterName":"ディープラーニングの概要","question":"誤差逆伝播法に関する説明として、最も適切なものを1つ選べ。","choices":["誤差逆伝播法で誤差を出力層から入力層へフィードバックさせるときに勾配が小さくなりすぎる問題は過学習と呼ばれる。","勾配消失問題を回避するため、ディープニューラルネットワークをより深くするのが有効である。","勾配消失問題を回避するには、適切な活性化関数を選ぶ必要がある。","誤差逆伝播法は、複数回の積分操作によって実現される。"],"correct":[2],"explanation":"誤差逆伝播法により学習する際、勾配消失問題は対策すべき重要な問題です。"},
{"id":67,"chapter":4,"chapterName":"ディープラーニングの概要","question":"ディープラーニングの膨大な計算量を処理する演算装置に関する説明として、最も不適切なものを1つ選べ。","choices":["GPUは画像に関する並列演算処理を得意としており、言語認識や音声のモデルにはCPUを用いる。","CPUは様々なタスクを順序よくこなすことを得意としており、大規模な並列演算の効率的な処理は得意でない。","ディープラーニング実装用のライブラリのほぼ全てがNVIDIA社製のGPU上での計算をサポートしている。","Google社はテンソル計算処理に最適化されたTPUと呼ばれる演算処理装置を開発している。"],"correct":[0],"explanation":"GPUはディープラーニング全般の並列演算に用いられ、画像処理のみに限定されるものではありません。"},
{"id":68,"chapter":4,"chapterName":"ディープラーニングの概要","question":"畳み込みニューラルネットワーク(CNN)を用いた学習を行う際、必要なデータについて述べたものとして、最も適切なものを1つ選べ。","choices":["学習に必要なデータが不足していると思われる場合、データ拡張を行い不足するデータ量を補うことがある。","バーニーおじさんのルール「モデルのパラメータ数の10倍のデータ数が必要」は厳守すべきである。","同じパラメータ数のモデルを学習する場合は、必ず同じデータ数にしなければならない。","ビッグデータは学習に必要である多様な特徴を含んでいるため、加工せずそのまま用いるべきである。"],"correct":[0],"explanation":"学習には膨大なデータを用いますが、不足する場合はデータ拡張で補います。"},
{"id":69,"chapter":4,"chapterName":"ディープラーニングの概要","question":"以下の説明に当てはまる活性化関数として、最も適切なものを1つ選べ。\n関数への入力値が0以下の場合には出力値が0となり、入力値が0より大きい場合には出力値として入力値と同じ値となる活性化関数。","choices":["シグモイド関数","ReLU関数","ステップ関数","ソフトマックス関数"],"correct":[1],"explanation":"ReLU関数を含めた各活性化関数の特長を理解しましょう。"},
{"id":70,"chapter":4,"chapterName":"ディープラーニングの概要","question":"以下の文章を読み、空欄に最もよく当てはまるものを1つ選べ。\nどんな値を入力しても0から1の間に変換されるため、最終的に確率を出力する際に有用な活性化関数は( )である。","choices":["tanh関数","シグモイド関数","ReLU関数","ステップ関数"],"correct":[1],"explanation":"シグモイド関数は0から1の値に変換します。tanh関数は-1から1、ReLU関数は0以上の値に変換します。"},
{"id":71,"chapter":4,"chapterName":"ディープラーニングの概要","question":"テストデータの一部が訓練データに紛れ込んだ場合に起こり得る問題として、最も適切なものを1つ選べ。","choices":["モデルの性能が不当に高く評価される。","モデルの性能が不当に低く評価される。","学習時間が増大する。","特に問題は生じない。"],"correct":[0],"explanation":"訓練データとテストデータが重複しないようにデータを分割しないといけません。"},
{"id":72,"chapter":4,"chapterName":"ディープラーニングの概要","question":"勾配降下法において、パラメータ更新の各回を表す語句として、最も適切なものを1つ選べ。","choices":["カーネル","パディング","ストライド","イテレーション"],"correct":[3],"explanation":"イテレーションと共にエポックなどの語句を理解しましょう。カーネルやパディング、ストライドは畳み込み層に関連する語句です。"},
{"id":73,"chapter":4,"chapterName":"ディープラーニングの概要","question":"勾配降下法などを用いてモデルを訓練する場合、オンライン学習、バッチ学習、ミニバッチ学習の3者の関係として、最も適切なものを1つ選べ。ただし全訓練データ数をNとする。","choices":["オンライン学習ではデータ数1、バッチ学習ではN、ミニバッチ学習ではn<N。","オンライン学習ではデータ数N、バッチ学習では1、ミニバッチ学習ではn<N。","オンライン学習ではデータ数N、バッチ学習ではn<N、ミニバッチ学習では1。","オンライン学習ではデータ数N、バッチ学習では1、ミニバッチ学習ではn>N。"],"correct":[0],"explanation":"オンライン学習、バッチ学習、ミニバッチ学習の違いを理解しましょう。"},
{"id":74,"chapter":4,"chapterName":"ディープラーニングの概要","question":"ハイパーパラメータの説明として、最も適切なものを1つ選べ。","choices":["モデルに含まれるパラメータの中で最も値が大きいパラメータである。","モデルの学習の過程で決定されないパラメータである。","別の学習済みモデルから再利用されたパラメータである。","前処理の際にのみ必要となるパラメータである。"],"correct":[1],"explanation":"ハイパーパラメータは学習で自動的に決められるものではなく、人があらかじめ決めておくパラメータです。"},
{"id":75,"chapter":4,"chapterName":"ディープラーニングの概要","question":"以下の文章を読み、空欄に最もよく当てはまるものを1つ選べ。\n( )は2つの確率分布の差を表す尺度である。誤差関数として利用する場合、学習中のモデルの予測が正解データと一致する割合が高いほど値は0に近づく。","choices":["交差エントロピー","結合エントロピー","部分エントロピー","情報エントロピー"],"correct":[0],"explanation":"選択肢2や3は存在しない誤差関数であり、選択肢4も誤差関数には利用しません。"},
{"id":76,"chapter":4,"chapterName":"ディープラーニングの概要","question":"確率的勾配降下法の説明として、最も適切なものを1つ選べ。","choices":["ニュートン法と同じ計算手法である。","ベイズの確率により勾配を求める手法である。","学習データごとに勾配を求めて修正量を出し、逐次更新する手法である。","固定の関数を微分した関数に学習データを代入し勾配を求める手法である。"],"correct":[2],"explanation":"確率的勾配降下法は勾配を求めて繰り返しパラメータを更新する手法です。"},
{"id":77,"chapter":4,"chapterName":"ディープラーニングの概要","question":"ノーフリーランチの定理が示す内容として、最も適切なものを1つ選べ。","choices":["未知の入力に対して常に良好な結果を出力するモデルは実現可能である。","モデルの次元数が増えるにつれて必要なデータは指数関数的に増加する。","競合する複数の仮説があるとき、もっとも単純な仮説を選ぶべきである。","あらゆる問題で性能の良い汎用最適化戦略は、理論上存在しない。"],"correct":[3],"explanation":"どんな問題でも通用するような学習プロセスは存在しないので、問題に応じて試行錯誤する必要があります。"},
{"id":78,"chapter":4,"chapterName":"ディープラーニングの概要","question":"以下の文章を読み、空欄(A)(B)に最もよく当てはまるものを1つ選べ。\n(A)は誤差関数が増加し始めた段階で学習を停止する手法である。誤差関数が増加に転じた後再び減少する(B)が起こりうるため、学習停止のタイミングには慎重な検討が必要である。","choices":["(A)ドロップアウト (B)二重降下現象","(A)ドロップアウト (B)勾配停留現象","(A)早期終了 (B)二重降下現象","(A)早期終了 (B)勾配停留現象"],"correct":[2],"explanation":"二重降下現象のように学習の繰り返し回数を多く設定しておかないと分からない現象もあります。"},
{"id":79,"chapter":4,"chapterName":"ディープラーニングの概要","question":"ディープラーニングにおいて過学習を防ぐ方法としてドロップアウトがある。ドロップアウトの説明として、最も適切なものを1つ選べ。","choices":["学習の繰り返しごとに、確率的に特定のニューロンを予測に用いない手法である。","過学習を避けるために学習を早く打ち切る手法である。","層が深くなっても誤差が伝播しやすくするため、層を飛び越えた結合を設ける手法である。","ペナルティ項を付加することで、重みの値の範囲を制限する手法である。"],"correct":[0],"explanation":"ドロップアウトはランダムに選択したニューロンの値を0にすることで予測に用いません。選択されるニューロンはエポックごとに変更します。"},
{"id":80,"chapter":4,"chapterName":"ディープラーニングの概要","question":"Random Erasingについての説明として、最も適切なものを1つ選べ。","choices":["画像処理に用いられるデータ拡張の1手法である。画像の一部分の画素をランダムに決定した値に変更することで新しい画像を生成する。","過学習に陥るリスクを軽減するため、学習の繰り返しごとにランダムにニューロンを除外して学習を進める手法である。","自然言語処理において文中の一部の単語をランダムにマスクして予測させることで学習を進める手法である。","学習済のネットワークにおいて推論に与える影響が少ないニューロン間の接続をランダムに取り除く手法である。"],"correct":[0],"explanation":"Random Erasingは画像処理に用いられるデータ拡張手法です。"},
{"id":81,"chapter":4,"chapterName":"ディープラーニングの概要","question":"ResNetにおいて、層をまたぐ結合の構造が導入されており、誤差の逆伝播を行いやすくなる。この結合の名称として、最も適切なものを1つ選べ。","choices":["サブ結合","スキップ結合","ドロップ結合","リカレント結合"],"correct":[1],"explanation":"スキップ結合は勾配消失問題を解消するResNetの重要な構成要素です。"},
{"id":82,"chapter":4,"chapterName":"ディープラーニングの概要","question":"畳み込みニューラルネットワーク(CNN)において、フィルタを移動させる幅の呼称として、最も適切なものを1つ選べ。","choices":["ストローク","パディング","ストライド","スライド"],"correct":[2],"explanation":"移動させる幅はストライド、入力データの周囲に領域を追加するのがパディングです。"},
{"id":83,"chapter":4,"chapterName":"ディープラーニングの概要","question":"データ拡張の目的として、最も不適切なものを1つ選べ。","choices":["学習データの水増し","未知のデータに対する汎化性能の向上","過学習の抑制","学習時間の短縮"],"correct":[3],"explanation":"データ拡張によりデータを水増しすることで汎化性能が向上し過学習を抑制できますが、その分学習時間は増えます。"},
{"id":84,"chapter":4,"chapterName":"ディープラーニングの概要","question":"畳み込みニューラルネットワーク(CNN)において畳み込み層の処理を行う前に、入力データの周囲に0など固定のデータを埋める処理の名称として、最も適切なものを1つ選べ。","choices":["パディング","ストライド","ドロップアウト","プーリング"],"correct":[0],"explanation":"パディングとストライドの処理を理解しておきましょう。"},
{"id":85,"chapter":4,"chapterName":"ディープラーニングの概要","question":"畳み込みニューラルネットワーク(CNN)の畳み込み層においては、(A)と呼ばれる小領域を動かしながら演算を行う。このとき動かす画素数のことを(B)という。","choices":["(A)フィルタ (B)エポック","(A)フィルタ (B)ストライド","(A)レイヤー (B)ストライド","(A)レイヤー (B)エポック"],"correct":[1],"explanation":"フィルタまたはカーネルの役割、ストライドの意味を理解しておきましょう。"},
{"id":86,"chapter":4,"chapterName":"ディープラーニングの概要","question":"畳み込みニューラルネットワーク(CNN)に関する説明として、最も適切なものを1つ選べ。","choices":["CNNは自然言語処理と強化学習のみに適したニューラルネットワークである。","畳み込み処理は生物の視覚の情報処理にヒントを得たニューラルネットワークの処理法の1つである。","CNNにスキップ結合を加えると学習速度が低下する。","CNNにはプーリング処理が必ず必要である。"],"correct":[1],"explanation":"どのようなアイデアで生まれたのか理解しておきましょう。"},
{"id":87,"chapter":4,"chapterName":"ディープラーニングの概要","question":"ゲートの数を削減することでLSTMにおける高い計算コストの削減を実現した手法の名称として、最も適切なものを1つ選べ。","choices":["LSTNet","Adam","GRU","BPTT"],"correct":[2],"explanation":"GRUはメモリをなくしゲート数も減らしたため、学習するパラメータ数が少なくなっています。"},
{"id":88,"chapter":4,"chapterName":"ディープラーニングの概要","question":"ニューラルネットワークの中間層の値を再帰させることによって、時系列データや言語などのデータに対応できるようにしたものの名称として、最も適切なものを1つ選べ。","choices":["DNN","RNN","CNN","DCNN"],"correct":[1],"explanation":"時系列データに対応する再帰構造がRNNの特徴です。"},
{"id":89,"chapter":4,"chapterName":"ディープラーニングの概要","question":"自然言語処理の文脈において、複数の単語ベクトルにどのベクトルを重要視するかをも含めて学習させる仕組みの名称として、最も適切なものを1つ選べ。","choices":["Attention","オートエンコーダ","ボルツマンマシン","敵対的生成ネットワーク(GAN)"],"correct":[0],"explanation":"Attentionにより単語ベクトル間の関連性を捉えることができます。"},
{"id":90,"chapter":5,"chapterName":"ディープラーニングの手法","question":"TransformerはEncoder-Decoderモデル構造を持っているが、Encoder側の計算に利用されるAttentionの種類として最も適切なものを1つ選べ。","choices":["Source-Target Attention","Encoder-Decoder Attention","Self-Attention","Encoder-Attention"],"correct":[2],"explanation":"Transformerではいくつかの Attention構造が採用されています。各Attention構造の違いを理解しておきましょう。"},
{"id":91,"chapter":5,"chapterName":"ディープラーニングの手法","question":"Transformerの説明として、不適切なものを1つ選べ。","choices":["リカレントニューラルネットワーク(RNN)を一切排除し、かわりにAttention機構を採用したEncoder-Decoderモデルである。","並列計算ができないため、データの処理に時間がかかる。","入力系列の中で遠い位置にある要素間の関係も直接考慮することができる。","Transformerの応用として様々なPretrained Modelが開発された。"],"correct":[1],"explanation":"TransformerはRNNの課題を解決するためのAttention構造や並列処理が可能な構造を持っています。"},
{"id":92,"chapter":5,"chapterName":"ディープラーニングの手法","question":"自然言語処理における位置エンコーディングに関する説明として、最も適切なものを1つ選べ。","choices":["時系列分析を可能とするために用いられる。","埋め込むことで計算コストが小さくなる。","モデルの解釈可能性を高めるために用いられる。","汎化性能を確認する指標として用いられる。"],"correct":[0],"explanation":"位置エンコーディングにより時系列データの並列処理が可能となりますが、計算コストは小さくなりません。"},
{"id":93,"chapter":5,"chapterName":"ディープラーニングの手法","question":"Google社によって開発された、Atrous convolutionを採用しているセマンティックセグメンテーションのモデルとして、最も適切なものを1つ選べ。","choices":["ImageNet","GoogLeNet","DeepLabV3","VGG16"],"correct":[2],"explanation":"DeepLabV3はセマンティックセグメンテーションのモデル、VGG16とGoogLeNetは物体認識のモデル、ImageNetはデータセットです。"},
{"id":94,"chapter":5,"chapterName":"ディープラーニングの手法","question":"Fast R-CNNの説明について、最も不適切なものを1つ選べ。","choices":["一枚の画像を分割してから、処理を行う。","画像に畳み込み層と最大値プーリング層を適用することによって特徴マップを作成する。","各物体の候補をRoIプーリング層によって特徴マップから固定長の特徴ベクトルに変換する。","Fast R-CNNはR-CNNよりも学習やテストにかかる処理が比較的高速で、さらに検出精度も高い。"],"correct":[0],"explanation":"Fast R-CNNはR-CNNを高速化した手法です。Selective Searchの利用方法の違いを理解しておきましょう。"},
{"id":95,"chapter":5,"chapterName":"ディープラーニングの手法","question":"畳み込みニューラルネットワーク(CNN)を用いた画像認識のモデルに関する説明として、最も不適切なものを1つ選べ。","choices":["VGGNetでは層が深くなるごとに特徴マップの縦横の幅は小さくなり、特徴マップの数は多くなる。","AlexNetは畳み込み層・プーリング層・全結合層を組み合わせたモデルである。","GoogLeNetはInceptionモジュールと呼ばれるネットワークを積み重ねた構造をしている。","ResNetは畳み込み層のみを積み重ねた構造をしている。"],"correct":[3],"explanation":"ResNetは勾配消失問題を解消できるスキップ結合を導入しています。"},
{"id":96,"chapter":5,"chapterName":"ディープラーニングの手法","question":"(A)は画像検出タスクに用いられる1手法であり、(B)セグメンテーションに分類される。(A)はPyramid Pooling Moduleと呼ばれるモジュールを有する。","choices":["(A)PSPNet (B)セマンティック","(A)PSPNet (B)インスタンス","(A)SegNet (B)セマンティック","(A)SegNet (B)インスタンス"],"correct":[0],"explanation":"セマンティックセグメンテーションとインスタンスセグメンテーションの違いについても理解しておきましょう。"},
{"id":97,"chapter":5,"chapterName":"ディープラーニングの手法","question":"LSTMで採用されている( )は誤差を内部にとどまらせることを目的としており、RNNの課題である時間の経過とともに過去の勾配が消えてしまう問題に対応している。","choices":["GRU","BPTT","CEC","Attention"],"correct":[2],"explanation":"LSTMを構成するメモリセル(CEC)、各種ゲートの役割を理解しておきましょう。"},
{"id":98,"chapter":5,"chapterName":"ディープラーニングの手法","question":"A-D変換の説明として、不適切なものを1つ選べ。","choices":["空気の振動として波状に伝わる音声のアナログデータをデジタルデータに変換する。","入力信号は符号化、量子化、標本化の順に処理される。","パルス符号変調(PCM)という方法が用いられることが一般的である。","連続値を離散的な値で近似するため、変換の誤差が生じる。"],"correct":[1],"explanation":"A-D変換は入力信号を標本化、量子化、符号化の順に処理します。"},
{"id":99,"chapter":5,"chapterName":"ディープラーニングの手法","question":"2016年にDeepMind社により発表された音声合成のニューラルネットワークアルゴリズムの名称として、最も適切なものを1つ選べ。","choices":["DQN","AlexNet","WaveNet","ResNet"],"correct":[2],"explanation":"WaveNetは音声合成の代表的なモデルです。DQNは強化学習手法、AlexNetとResNetは畳み込みニューラルネットワークのモデルです。"},
{"id":100,"chapter":5,"chapterName":"ディープラーニングの手法","question":"周波数スペクトルの形状を表すものを(A)といい音色を表す。(A)を求める一般的な方法は(B)を用いるものである。","choices":["(A)フォルマント周波数 (B)メル周波数ケプストラム係数(MFCC)","(A)スペクトル包絡 (B)メル周波数ケプストラム係数(MFCC)","(A)フォルマント周波数 (B)隠れマルコフモデル","(A)フォルマント周波数 (B)スペクトル包絡"],"correct":[1],"explanation":"フォルマント周波数は音声の共振周波数です。周波数のピークをフォルマントと呼びます。"},
{"id":101,"chapter":5,"chapterName":"ディープラーニングの手法","question":"キャプション生成の説明として、最も適切なものを1つ選べ。","choices":["入力画像を説明する自然言語文を出力する。","文書に書かれている手書き文字などを読み取る。","画像から対象物の位置を矩形領域で特定する。","画素単位でクラス識別を行う。"],"correct":[0],"explanation":"2はOCR、3は物体検出、4はセマンティックセグメンテーションです。"},
{"id":102,"chapter":5,"chapterName":"ディープラーニングの手法","question":"BERTについて、最も不適切なものを1つ選べ。","choices":["ラベルが付与されていないデータを用いて事前学習を行う。","文章の冒頭から末尾までの一方の方向に対してTransformerを適用している。","Masked Language Modelを利用している。","Next Sentence Predictionを利用している。"],"correct":[1],"explanation":"BERTは文頭から文末までの順方向と文末から文頭までの逆方向の両方に対応した双方向の処理を行うことが特長です。"},
{"id":103,"chapter":5,"chapterName":"ディープラーニングの手法","question":"BoW(Bag-of-Words)に関する説明として、最も適切なものを1つ選べ。","choices":["単語の出現回数によって言語分析を行うモデルである。","語順を考慮した言語分析を行うモデルである。","自然言語処理において意味のある特定の熟語群を示す用語である。","自然言語処理において相槌など文意に大きな影響を与えない単語群を示す用語である。"],"correct":[0],"explanation":"BoWは語順を考慮せずに単語の出現頻度を特徴ベクトルとします。"},
{"id":104,"chapter":5,"chapterName":"ディープラーニングの手法","question":"音声認識に用いられるアルゴリズムの1つに(A)がある。(A)は空文字を挿入し同一の(B)を縮約することで入力と出力の数を一致させることができる。","choices":["(A)CEC (B)音素","(A)CEC (B)音韻","(A)CTC (B)音素","(A)CTC (B)音韻"],"correct":[2],"explanation":"CTCにより同じ音素が連続する場合でも1つの音素にすることができます。"},
{"id":105,"chapter":5,"chapterName":"ディープラーニングの手法","question":"CAMに関する説明として、最も不適切なものを1つ選べ。","choices":["CAMは2016年に発表された手法であり、画像認識の判断根拠を可視化する初めての手法として知られている。","CAMはグローバルアベレージプーリング(GAP)を有する画像認識モデルにおいてのみ適用可能である。","Grad-CAMは2017年に発表された手法であり、勾配情報を用いずに判断根拠を可視化する手法である。","Grad-CAMはGAPを有しない画像認識モデルでも利用可能であるため幅広いタスクで用いる。"],"correct":[2],"explanation":"Grad-CAMはGAPを有しないモデルにも適用でき、勾配情報に対してGAPを行います。"},
{"id":106,"chapter":5,"chapterName":"ディープラーニングの手法","question":"ディープニューラルネットワーク(DNN)のパラメータを表現するビット数を削減することでモデルを圧縮する手法として、最も適切なものを1つ選べ。","choices":["蒸留","プルーニング","量子化","正規化"],"correct":[2],"explanation":"蒸留は大規模なモデルの知識を小さなモデルに伝える技術、プルーニングはモデル内の不要なパラメータを削除する技術、正規化は特徴マップの値をスケーリングする技術です。"}
];

 :

// ===== CHAPTERS =====
function getChapters() {
  var chapters = {};
  for (var i = 0; i < QUESTIONS.length; i++) {
    var q = QUESTIONS[i];
    if (!chapters[q.chapter]) chapters[q.chapter] = q.chapterName;
  }
  return chapters;
}

var LABELS = ['A','B','C','D','E','F','G','H'];
var progress = loadProgress();
var currentQuiz = [];
var currentIndex = 0;
var quizResults = [];
var currentMode = 'normal';
var selectedChoices = [];
var isMultiSelect = false;

function loadProgress() {
  try {
    var data = localStorage.getItem('gTestProgress');
    return data ? JSON.parse(data) : {};
  } catch(e) { return {}; }
}
function saveProgress() {
  localStorage.setItem('gTestProgress', JSON.stringify(progress));
}

function showScreen(id) {
  var screens = document.querySelectorAll('.screen');
  for (var i = 0; i < screens.length; i++) screens[i].classList.remove('active');
  document.getElementById(id).classList.add('active');
  window.scrollTo(0, 0);
}
function goTop() { renderTop(); showScreen('topScreen'); }

function renderTop() { renderOverallStats(); renderChapterAnalysis(); }

function renderOverallStats() {
  var el = document.getElementById('overallStats');
  var allAnswered = Object.keys(progress);
  if (allAnswered.length === 0) {
    el.innerHTML = '<div class="no-data fade-in"><div class="no-data-icon">📚</div><p>まだ問題を解いていません。<br>下のメニューから学習を始めましょう！<br><br><span style="font-size:0.75rem;color:var(--text-sub)">全' + QUESTIONS.length + '問収録</span></p></div>';
    return;
  }
  var totalCorrect = 0, totalCount = 0;
  for (var i = 0; i < allAnswered.length; i++) {
    totalCount++;
    if (progress[allAnswered[i]].correct) totalCorrect++;
  }
  var rate = Math.round((totalCorrect / totalCount) * 100);
  el.innerHTML = '<div class="overall-stats fade-in"><div class="overall-rate">' + rate + '%</div><div class="overall-label">全体正答率</div><div class="overall-detail"><span>正解 ' + totalCorrect + '問</span><span>不正解 ' + (totalCount - totalCorrect) + '問</span><span>合計 ' + totalCount + '/' + QUESTIONS.length + '問</span></div></div>';
}

function renderChapterAnalysis() {
  var el = document.getElementById('chapterAnalysis');
  var allAnswered = Object.keys(progress);
  if (allAnswered.length === 0) { el.innerHTML = ''; return; }
  var stats = {};
  for (var i = 0; i < allAnswered.length; i++) {
    var qid = allAnswered[i];
    var q = null;
    for (var j = 0; j < QUESTIONS.length; j++) {
      if (QUESTIONS[j].id === parseInt(qid)) { q = QUESTIONS[j]; break; }
    }
    if (!q) continue;
    var ch = q.chapter;
    if (!stats[ch]) stats[ch] = { total: 0, correct: 0, incorrect: 0, name: q.chapterName };
    stats[ch].total++;
    if (progress[qid].correct) stats[ch].correct++;
    else stats[ch].incorrect++;
  }
  var entries = [];
  for (var key in stats) {
    stats[key].rate = Math.round((stats[key].correct / stats[key].total) * 100);
    stats[key].chapter = key;
    entries.push(stats[key]);
  }
  entries.sort(function(a, b) { return a.rate - b.rate; });
  var html = '<div class="section-title">章別分析（苦手順）</div>';
  for (var i = 0; i < entries.length; i++) {
    var s = entries[i];
    var cls = s.rate >= 80 ? 'excellent' : s.rate >= 60 ? 'good' : s.rate >= 40 ? 'needs-work' : 'weak';
    var label = s.rate >= 80 ? '優秀' : s.rate >= 60 ? '良好' : s.rate >= 40 ? '要改善' : '苦手';
    var chapterTotal = 0;
    for (var j = 0; j < QUESTIONS.length; j++) {
      if (QUESTIONS[j].chapter === parseInt(s.chapter)) chapterTotal++;
    }
    html += '<div class="chapter-card ' + cls + ' fade-in"><div class="chapter-header"><div class="chapter-name">第' + s.chapter + '章: ' + s.name + '<span class="badge ' + cls + '">' + label + '</span></div><div class="chapter-rate">' + s.rate + '%</div></div><div class="chapter-detail">正解: ' + s.correct + '問　不正解: ' + s.incorrect + '問　（' + s.total + '/' + chapterTotal + '問 回答済）</div><div class="progress-bar"><div class="progress-fill" style="width:' + s.rate + '%"></div></div></div>';
  }
  el.innerHTML = html;
}

function showChapterSelect(mode) {
  currentMode = mode;
  if (mode === 'all') { startQuiz(QUESTIONS.slice()); return; }
  var el = document.getElementById('chapterList');
  var chapters = getChapters();
  var html = '';
  var keys = Object.keys(chapters);
  for (var i = 0; i < keys.length; i++) {
    var ch = keys[i];
    var name = chapters[ch];
    var count = 0, answered = 0;
    for (var j = 0; j < QUESTIONS.length; j++) {
      if (QUESTIONS[j].chapter === parseInt(ch)) {
        count++;
        if (progress[QUESTIONS[j].id]) answered++;
      }
    }
    html += '<div class="chapter-select-card fade-in" onclick="startChapterQuiz(' + ch + ')"><div class="chapter-select-info"><h3>第' + ch + '章: ' + name + '</h3><p>' + count + '問（' + answered + '問 回答済）</p></div><div class="chapter-select-arrow">›</div></div>';
  }
  el.innerHTML = html;
  showScreen('chapterSelectScreen');
}

function startChapterQuiz(chapter) {
  var qs = [];
  for (var i = 0; i < QUESTIONS.length; i++) {
    if (QUESTIONS[i].chapter === chapter) qs.push(QUESTIONS[i]);
  }
  startQuiz(qs);
}

function startReviewMode() {
  var qs = [];
  var keys = Object.keys(progress);
  for (var i = 0; i < keys.length; i++) {
    if (!progress[keys[i]].correct) {
      var id = parseInt(keys[i]);
      for (var j = 0; j < QUESTIONS.length; j++) {
        if (QUESTIONS[j].id === id) { qs.push(QUESTIONS[j]); break; }
      }
    }
  }
  if (qs.length === 0) { showToast('復習する問題がありません'); return; }
  currentMode = 'review';
  startQuiz(qs);
}

function startQuiz(questions) {
  currentQuiz = questions.sort(function() { return Math.random() - 0.5; });
  currentIndex = 0;
  quizResults = [];
  showScreen('quizScreen');
  renderQuestion();
}

function renderQuestion() {
  var q = currentQuiz[currentIndex];
  var total = currentQuiz.length;
  var correctArr = Array.isArray(q.correct) ? q.correct : [q.correct];
  isMultiSelect = correctArr.length > 1;
  selectedChoices = [];

  document.getElementById('quizProgressFill').style.width = ((currentIndex / total) * 100) + '%';
  document.getElementById('quizProgressText').textContent = (currentIndex + 1) + '/' + total;

  var choicesHtml = '';
  for (var i = 0; i < q.choices.length; i++) {
    if (isMultiSelect) {
      choicesHtml += '<button class="choice-btn" id="choice' + i + '" onclick="toggleChoice(' + i + ')"><span class="choice-label">' + LABELS[i] + '</span><span class="choice-text">' + q.choices[i] + '</span></button>';
    } else {
      choicesHtml += '<button class="choice-btn" id="choice' + i + '" onclick="selectSingleAnswer(' + i + ')"><span class="choice-label">' + LABELS[i] + '</span><span class="choice-text">' + q.choices[i] + '</span></button>';
    }
  }

  var typeTag = isMultiSelect ? '<div class="question-type">複数選択（' + correctArr.length + 'つ選択）</div>' : '';

  document.getElementById('quizContent').innerHTML = '<div class="question-card fade-in"><div class="question-number">第' + q.chapter + '章: ' + q.chapterName + '</div><div class="question-text">' + q.question + '</div>' + typeTag + '</div><div class="choices fade-in">' + choicesHtml + '</div><button class="submit-btn' + (isMultiSelect ? ' show' : '') + '" id="submitBtn" onclick="submitMultiAnswer()" disabled>回答を確定する</button><div class="result-box" id="resultBox"><div class="result-icon" id="resultIcon"></div><div class="result-explanation" id="resultExplanation"></div><button class="copy-btn" id="copyBtn" onclick="copyQuestion()">問題と解説をコピー（AI壁打ち用）</button><button class="next-btn" id="nextBtn" onclick="nextQuestion()">次の問題へ</button></div>';
}

function selectSingleAnswer(selected) {
  selectedChoices = [selected];
  evaluateAnswer();
}

function toggleChoice(idx) {
  var btn = document.getElementById('choice' + idx);
  var pos = selectedChoices.indexOf(idx);
  if (pos > -1) {
    selectedChoices.splice(pos, 1);
    btn.classList.remove('selected');
  } else {
    selectedChoices.push(idx);
    btn.classList.add('selected');
  }
  document.getElementById('submitBtn').disabled = selectedChoices.length === 0;
}

function submitMultiAnswer() {
  evaluateAnswer();
}

function evaluateAnswer() {
  var q = currentQuiz[currentIndex];
  var correctArr = Array.isArray(q.correct) ? q.correct : [q.correct];
  var selectedArr = selectedChoices.slice().sort(function(a,b){return a-b;});
  var correctSorted = correctArr.slice().sort(function(a,b){return a-b;});
  var isCorrect = JSON.stringify(selectedArr) === JSON.stringify(correctSorted);

  progress[q.id] = { correct: isCorrect, lastAnswered: Date.now() };
  saveProgress();
  quizResults.push({ question: q, selected: selectedArr, isCorrect: isCorrect });

  var submitBtn = document.getElementById('submitBtn');
  if (submitBtn) submitBtn.style.display = 'none';

  var btns = document.querySelectorAll('.choice-btn');
  for (var i = 0; i < btns.length; i++) {
    btns[i].onclick = null;
    btns[i].style.cursor = 'default';
    if (correctArr.indexOf(i) > -1) {
      btns[i].classList.remove('selected');
      btns[i].classList.add(selectedArr.indexOf(i) > -1 ? 'correct' : 'show-correct');
    } else if (selectedArr.indexOf(i) > -1) {
      btns[i].classList.remove('selected');
      btns[i].classList.add('incorrect');
    }
  }

  var box = document.getElementById('resultBox');
  box.classList.add('show');
  box.classList.add(isCorrect ? 'correct-result' : 'incorrect-result');
  document.getElementById('resultIcon').textContent = isCorrect ? '⭕ 正解！' : '❌ 不正解';
  document.getElementById('resultExplanation').textContent = q.explanation;

  if (currentIndex >= currentQuiz.length - 1) {
    document.getElementById('nextBtn').textContent = '結果を見る';
  }
}

function nextQuestion() {
  currentIndex++;
  if (currentIndex >= currentQuiz.length) showSummary();
  else { renderQuestion(); window.scrollTo(0, 0); }
}

function copyQuestion() {
  var q = currentQuiz[currentIndex];
  var r = quizResults[quizResults.length - 1];
  var correctArr = Array.isArray(q.correct) ? q.correct : [q.correct];
  var correctStrs = [];
  for (var i = 0; i < correctArr.length; i++) correctStrs.push(LABELS[correctArr[i]] + '. ' + q.choices[correctArr[i]]);
  var selectedStrs = [];
  for (var i = 0; i < r.selected.length; i++) selectedStrs.push(LABELS[r.selected[i]] + '. ' + q.choices[r.selected[i]]);
  var choiceLines = [];
  for (var i = 0; i < q.choices.length; i++) choiceLines.push(LABELS[i] + '. ' + q.choices[i]);

  var text = '【G検定 問題】\n第' + q.chapter + '章: ' + q.chapterName + '\n\n■ 問題\n' + q.question + '\n\n■ 選択肢\n' + choiceLines.join('\n') + '\n\n■ 正解: ' + correctStrs.join(', ') + '\n■ 自分の回答: ' + selectedStrs.join(', ') + '\n\n■ 解説\n' + q.explanation + '\n\n---\nこの問題についてさらに深く理解したいです。関連する概念や実務での応用について教えてください。';

  try {
    navigator.clipboard.writeText(text).then(function() {
      document.getElementById('copyBtn').textContent = 'コピーしました！';
      document.getElementById('copyBtn').classList.add('copied');
      showToast('クリップボードにコピーしました');
    });
  } catch(e) {
    fallbackCopy(text);
    document.getElementById('copyBtn').textContent = 'コピーしました！';
    document.getElementById('copyBtn').classList.add('copied');
    showToast('コピーしました');
  }
}

function confirmQuit() {
  if (quizResults.length > 0) {
    if (confirm('学習を中断しますか？ここまでの回答は保存されています。')) goTop();
  } else goTop();
}

function showSummary() {
  showScreen('summaryScreen');
  var total = quizResults.length;
  var correct = 0;
  for (var i = 0; i < quizResults.length; i++) { if (quizResults[i].isCorrect) correct++; }
  var rate = Math.round((correct / total) * 100);
  var cls = rate >= 80 ? 'great' : rate >= 60 ? 'good' : rate >= 40 ? 'needs-work' : 'poor';
  var wrongResults = [];
  for (var i = 0; i < quizResults.length; i++) { if (!quizResults[i].isCorrect) wrongResults.push(quizResults[i]); }

  var wrongHtml = '';
  if (wrongResults.length > 0) {
    wrongHtml = '<div class="section-title" style="margin-top:32px">間違えた問題</div>';
    for (var i = 0; i < wrongResults.length; i++) {
      var q = wrongResults[i].question;
      var idx = quizResults.indexOf(wrongResults[i]);
      wrongHtml += '<div class="summary-q-item fade-in"><div class="summary-q-icon">❌</div><div class="summary-q-text"><strong>第' + q.chapter + '章</strong> ' + q.question.substring(0, 60) + '...</div><button class="summary-q-copy" onclick="copySummaryQuestion(' + idx + ')">コピー</button></div>';
    }
  }

  document.getElementById('summaryContent').innerHTML = '<div class="summary-hero fade-in"><div class="summary-score ' + cls + '">' + rate + '%</div><div class="summary-label">正答率</div><div class="summary-detail"><div class="summary-detail-item"><div class="summary-detail-num" style="color:var(--green)">' + correct + '</div><div class="summary-detail-label">正解</div></div><div class="summary-detail-item"><div class="summary-detail-num" style="color:var(--red)">' + (total - correct) + '</div><div class="summary-detail-label">不正解</div></div><div class="summary-detail-item"><div class="summary-detail-num">' + total + '</div><div class="summary-detail-label">合計</div></div></div></div><div class="summary-questions">' + wrongHtml + '</div>' + (wrongResults.length > 0 ? '<button class="btn-secondary" style="margin-top:16px" onclick="copyAllWrong()">間違えた問題をすべてコピー</button>' : '') + '<div class="action-btns"><button class="btn-primary" onclick="goTop()">トップに戻る</button>' + (wrongResults.length > 0 ? '<button class="btn-secondary" onclick="retryWrong()">間違えた問題だけ再挑戦</button>' : '') + '</div>';
}

function copySummaryQuestion(idx) {
  var r = quizResults[idx];
  var q = r.question;
  var correctArr = Array.isArray(q.correct) ? q.correct : [q.correct];
  var correctStrs = [];
  for (var i = 0; i < correctArr.length; i++) correctStrs.push(LABELS[correctArr[i]] + '. ' + q.choices[correctArr[i]]);
  var selectedStrs = [];
  for (var i = 0; i < r.selected.length; i++) selectedStrs.push(LABELS[r.selected[i]] + '. ' + q.choices[r.selected[i]]);
  var choiceLines = [];
  for (var i = 0; i < q.choices.length; i++) choiceLines.push(LABELS[i] + '. ' + q.choices[i]);
  var text = '【G検定 問題】\n第' + q.chapter + '章: ' + q.chapterName + '\n\n■ 問題\n' + q.question + '\n\n■ 選択肢\n' + choiceLines.join('\n') + '\n\n■ 正解: ' + correctStrs.join(', ') + '\n■ 自分の回答: ' + selectedStrs.join(', ') + '\n\n■ 解説\n' + q.explanation + '\n\n---\nこの問題について、なぜ間違えたか分析し、関連する概念を教えてください。';
  try { navigator.clipboard.writeText(text).then(function() { showToast('コピーしました'); }); }
  catch(e) { fallbackCopy(text); showToast('コピーしました'); }
}

function copyAllWrong() {
  var wrongs = [];
  for (var i = 0; i < quizResults.length; i++) { if (!quizResults[i].isCorrect) wrongs.push(quizResults[i]); }
  var text = '【G検定 間違えた問題まとめ】\n\n';
  for (var i = 0; i < wrongs.length; i++) {
    var q = wrongs[i].question;
    var correctArr = Array.isArray(q.correct) ? q.correct : [q.correct];
    var correctStrs = [];
    for (var j = 0; j < correctArr.length; j++) correctStrs.push(LABELS[correctArr[j]] + '. ' + q.choices[correctArr[j]]);
    var selectedStrs = [];
    for (var j = 0; j < wrongs[i].selected.length; j++) selectedStrs.push(LABELS[wrongs[i].selected[j]] + '. ' + q.choices[wrongs[i].selected[j]]);
    var choiceLines = [];
    for (var j = 0; j < q.choices.length; j++) choiceLines.push(LABELS[j] + '. ' + q.choices[j]);
    text += '━━━ 問題' + (i + 1) + ' ━━━\n第' + q.chapter + '章: ' + q.chapterName + '\n\n■ 問題\n' + q.question + '\n\n■ 選択肢\n' + choiceLines.join('\n') + '\n\n■ 正解: ' + correctStrs.join(', ') + '\n■ 自分の回答: ' + selectedStrs.join(', ') + '\n\n■ 解説\n' + q.explanation + '\n\n';
  }
  text += '---\n上記の間違えた問題について、共通する弱点パターンを分析し、効率的な復習方法を提案してください。';
  try { navigator.clipboard.writeText(text).then(function() { showToast('すべてコピーしました'); }); }
  catch(e) { fallbackCopy(text); showToast('コピーしました'); }
}

function retryWrong() {
  var qs = [];
  for (var i = 0; i < quizResults.length; i++) {
    if (!quizResults[i].isCorrect) qs.push(quizResults[i].question);
  }
  startQuiz(qs);
}

function fallbackCopy(text) {
  var ta = document.createElement('textarea');
  ta.value = text; ta.style.position = 'fixed'; ta.style.left = '-9999px';
  document.body.appendChild(ta); ta.select();
  document.execCommand('copy'); document.body.removeChild(ta);
}
function showToast(msg) {
  var t = document.getElementById('toast');
  t.textContent = msg; t.classList.add('show');
  setTimeout(function() { t.classList.remove('show'); }, 2000);
}
function showResetDialog() { document.getElementById('resetOverlay').classList.add('show'); }
function closeResetDialog() { document.getElementById('resetOverlay').classList.remove('show'); }
function confirmReset() {
  progress = {}; localStorage.removeItem('gTestProgress');
  closeResetDialog(); showToast('データをリセットしました'); goTop();
}

renderTop();
</script>
</body>
</html>
